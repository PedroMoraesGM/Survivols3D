// <auto-generated>
// This code was auto-generated by a tool, every time
// the tool executes this code will be reset.
//
// If you need to extend the classes generated to add
// fields or methods to them, please create partial
// declarations in another file.
// </auto-generated>
#pragma warning disable 0109
#pragma warning disable 1591


namespace Quantum {
  using Photon.Deterministic;
  using Quantum;
  using Quantum.Core;
  using Quantum.Collections;
  using Quantum.Inspector;
  using Quantum.Physics2D;
  using Quantum.Physics3D;
  using Byte = System.Byte;
  using SByte = System.SByte;
  using Int16 = System.Int16;
  using UInt16 = System.UInt16;
  using Int32 = System.Int32;
  using UInt32 = System.UInt32;
  using Int64 = System.Int64;
  using UInt64 = System.UInt64;
  using Boolean = System.Boolean;
  using String = System.String;
  using Object = System.Object;
  using FlagsAttribute = System.FlagsAttribute;
  using SerializableAttribute = System.SerializableAttribute;
  using MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute;
  using MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions;
  using FieldOffsetAttribute = System.Runtime.InteropServices.FieldOffsetAttribute;
  using StructLayoutAttribute = System.Runtime.InteropServices.StructLayoutAttribute;
  using LayoutKind = System.Runtime.InteropServices.LayoutKind;
  #if QUANTUM_UNITY //;
  using TooltipAttribute = UnityEngine.TooltipAttribute;
  using HeaderAttribute = UnityEngine.HeaderAttribute;
  using SpaceAttribute = UnityEngine.SpaceAttribute;
  using RangeAttribute = UnityEngine.RangeAttribute;
  using HideInInspectorAttribute = UnityEngine.HideInInspector;
  using PreserveAttribute = UnityEngine.Scripting.PreserveAttribute;
  using FormerlySerializedAsAttribute = UnityEngine.Serialization.FormerlySerializedAsAttribute;
  using MovedFromAttribute = UnityEngine.Scripting.APIUpdating.MovedFromAttribute;
  using CreateAssetMenu = UnityEngine.CreateAssetMenuAttribute;
  using RuntimeInitializeOnLoadMethodAttribute = UnityEngine.RuntimeInitializeOnLoadMethodAttribute;
  #endif //;
  
  public enum GameState : int {
    None,
    Waiting,
    Countdown,
    Goal,
    Playing,
    GameOver,
  }
  public enum UpgradeCategory : int {
    WeaponUnlock,
    WeaponUpgrade,
  }
  [System.FlagsAttribute()]
  public enum InputButtons : int {
    Forward = 1 << 0,
    Reset = 1 << 1,
    ChoiceFirst = 1 << 2,
    ChoiceSecond = 1 << 3,
    ChoiceThird = 1 << 4,
  }
  public static unsafe partial class FlagsExtensions {
    public static Boolean IsFlagSet(this InputButtons self, InputButtons flag) {
      return (self & flag) == flag;
    }
    public static InputButtons SetFlag(this InputButtons self, InputButtons flag) {
      return self | flag;
    }
    public static InputButtons ClearFlag(this InputButtons self, InputButtons flag) {
      return self & ~flag;
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet128 {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[2];
    public const Int32 BitsSize = 128;
    public Int32 Length {
      get {
        return 128;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet128*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 128, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet128 FromArray(UInt64[] values) {
      Assert.Always(2 == values.Length, "Invalid array size", values.Length);
      BitSet128 result = default;
      for (int i = 0; i < 2; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 128);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 128);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 16);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Int32 GetSetCount() {
      fixed (UInt64* p = Bits) {
        int result = 0;
        result += Maths.CountSetBits(p[0]);
        result += Maths.CountSetBits(p[1]);
        return result;
      }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsAnySet() {
      fixed (UInt64* p = Bits) {
        if (p[0] != 0) return true;
        if (p[1] != 0) return true;
        return false;
      }
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 4463;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 2);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet128*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 2);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet2048 {
    public const Int32 SIZE = 256;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[32];
    public const Int32 BitsSize = 2048;
    public Int32 Length {
      get {
        return 2048;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet2048*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 2048, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet2048 FromArray(UInt64[] values) {
      Assert.Always(32 == values.Length, "Invalid array size", values.Length);
      BitSet2048 result = default;
      for (int i = 0; i < 32; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 2048);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 2048);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 256);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Int32 GetSetCount() {
      fixed (UInt64* p = Bits) {
        int result = 0;
        for (int i = 0; i < 32; ++i) {
          result += Maths.CountSetBits(p[i]);
        }
        return result;
      }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsAnySet() {
      fixed (UInt64* p = Bits) {
        for (int i = 0; i < 32; ++i) {
          if (p[i] != 0) return true;
        }
        return false;
      }
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 3319;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 32);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet2048*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 32);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet256 {
    public const Int32 SIZE = 32;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[4];
    public const Int32 BitsSize = 256;
    public Int32 Length {
      get {
        return 256;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet256*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 256, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet256 FromArray(UInt64[] values) {
      Assert.Always(4 == values.Length, "Invalid array size", values.Length);
      BitSet256 result = default;
      for (int i = 0; i < 4; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 256);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 256);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 32);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Int32 GetSetCount() {
      fixed (UInt64* p = Bits) {
        int result = 0;
        result += Maths.CountSetBits(p[0]);
        result += Maths.CountSetBits(p[1]);
        result += Maths.CountSetBits(p[2]);
        result += Maths.CountSetBits(p[3]);
        return result;
      }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsAnySet() {
      fixed (UInt64* p = Bits) {
        if (p[0] != 0) return true;
        if (p[1] != 0) return true;
        if (p[2] != 0) return true;
        if (p[3] != 0) return true;
        return false;
      }
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 14057;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 4);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet256*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 4);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet4096 {
    public const Int32 SIZE = 512;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[64];
    public const Int32 BitsSize = 4096;
    public Int32 Length {
      get {
        return 4096;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet4096*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 4096, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet4096 FromArray(UInt64[] values) {
      Assert.Always(64 == values.Length, "Invalid array size", values.Length);
      BitSet4096 result = default;
      for (int i = 0; i < 64; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 4096);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 4096);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 512);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Int32 GetSetCount() {
      fixed (UInt64* p = Bits) {
        int result = 0;
        for (int i = 0; i < 64; ++i) {
          result += Maths.CountSetBits(p[i]);
        }
        return result;
      }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsAnySet() {
      fixed (UInt64* p = Bits) {
        for (int i = 0; i < 64; ++i) {
          if (p[i] != 0) return true;
        }
        return false;
      }
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 1433;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 64);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet4096*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 64);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet512 {
    public const Int32 SIZE = 64;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[8];
    public const Int32 BitsSize = 512;
    public Int32 Length {
      get {
        return 512;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet512*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 512, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet512 FromArray(UInt64[] values) {
      Assert.Always(8 == values.Length, "Invalid array size", values.Length);
      BitSet512 result = default;
      for (int i = 0; i < 8; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 512);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 512);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 64);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Int32 GetSetCount() {
      fixed (UInt64* p = Bits) {
        int result = 0;
        for (int i = 0; i < 8; ++i) {
          result += Maths.CountSetBits(p[i]);
        }
        return result;
      }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsAnySet() {
      fixed (UInt64* p = Bits) {
        for (int i = 0; i < 8; ++i) {
          if (p[i] != 0) return true;
        }
        return false;
      }
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 17491;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 8);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet512*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 8);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet6 {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[1];
    public const Int32 BitsSize = 6;
    public Int32 Length {
      get {
        return 6;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet6*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 6, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet6 FromArray(UInt64[] values) {
      Assert.Always(1 == values.Length, "Invalid array size", values.Length);
      BitSet6 result = default;
      for (int i = 0; i < 1; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 6);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 6);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 8);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Int32 GetSetCount() {
      fixed (UInt64* p = Bits) {
        int result = 0;
        result += Maths.CountSetBits(p[0] & 0x3FUL);
        return result;
      }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsAnySet() {
      fixed (UInt64* p = Bits) {
        if ((p[0] & 0x3FUL) != 0) return true;
        return false;
      }
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 13669;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 1);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet6*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 1);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct EnemyInfo {
    public const Int32 SIZE = 32;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public EntityRef Entity;
    [FieldOffset(8)]
    public FPVector3 Position;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 14407;
        hash = hash * 31 + Entity.GetHashCode();
        hash = hash * 31 + Position.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (EnemyInfo*)ptr;
        EntityRef.Serialize(&p->Entity, serializer);
        FPVector3.Serialize(&p->Position, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct EnemySpawnEntry {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public AssetRef<EntityPrototype> Prefab;
    [FieldOffset(0)]
    public Int32 MinWave;
    [FieldOffset(16)]
    public FP Weight;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 6211;
        hash = hash * 31 + Prefab.GetHashCode();
        hash = hash * 31 + MinWave.GetHashCode();
        hash = hash * 31 + Weight.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (EnemySpawnEntry*)ptr;
        serializer.Stream.Serialize(&p->MinWave);
        AssetRef.Serialize(&p->Prefab, serializer);
        FP.Serialize(&p->Weight, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Input {
    public const Int32 SIZE = 96;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(80)]
    public FPVector2 MoveAxis;
    [FieldOffset(64)]
    public FPVector2 LookDelta;
    [FieldOffset(36)]
    public Button Forward;
    [FieldOffset(48)]
    public Button Reset;
    [FieldOffset(0)]
    public Button ChoiceFirst;
    [FieldOffset(12)]
    public Button ChoiceSecond;
    [FieldOffset(24)]
    public Button ChoiceThird;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 19249;
        hash = hash * 31 + MoveAxis.GetHashCode();
        hash = hash * 31 + LookDelta.GetHashCode();
        hash = hash * 31 + Forward.GetHashCode();
        hash = hash * 31 + Reset.GetHashCode();
        hash = hash * 31 + ChoiceFirst.GetHashCode();
        hash = hash * 31 + ChoiceSecond.GetHashCode();
        hash = hash * 31 + ChoiceThird.GetHashCode();
        return hash;
      }
    }
    static partial void GetMaxCountCodeGen(ref int maxCount) {
      maxCount = 6;
    }
    public Boolean IsDown(InputButtons button) {
      switch (button) {
        case InputButtons.Forward: return Forward.IsDown;
        case InputButtons.Reset: return Reset.IsDown;
        case InputButtons.ChoiceFirst: return ChoiceFirst.IsDown;
        case InputButtons.ChoiceSecond: return ChoiceSecond.IsDown;
        case InputButtons.ChoiceThird: return ChoiceThird.IsDown;
        default: return false;
      }
    }
    public Boolean WasPressed(InputButtons button) {
      switch (button) {
        case InputButtons.Forward: return Forward.WasPressed;
        case InputButtons.Reset: return Reset.WasPressed;
        case InputButtons.ChoiceFirst: return ChoiceFirst.WasPressed;
        case InputButtons.ChoiceSecond: return ChoiceSecond.WasPressed;
        case InputButtons.ChoiceThird: return ChoiceThird.WasPressed;
        default: return false;
      }
    }
    static partial void SerializeCodeGen(void* ptr, FrameSerializer serializer) {
        var p = (Input*)ptr;
        Button.Serialize(&p->ChoiceFirst, serializer);
        Button.Serialize(&p->ChoiceSecond, serializer);
        Button.Serialize(&p->ChoiceThird, serializer);
        Button.Serialize(&p->Forward, serializer);
        Button.Serialize(&p->Reset, serializer);
        FPVector2.Serialize(&p->LookDelta, serializer);
        FPVector2.Serialize(&p->MoveAxis, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct PlayerInfo {
    public const Int32 SIZE = 32;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public EntityRef Entity;
    [FieldOffset(8)]
    public FPVector3 Position;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 13049;
        hash = hash * 31 + Entity.GetHashCode();
        hash = hash * 31 + Position.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (PlayerInfo*)ptr;
        EntityRef.Serialize(&p->Entity, serializer);
        FPVector3.Serialize(&p->Position, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct SpawnSettings {
    public const Int32 SIZE = 40;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public AssetRef<EntityPrototype> EnemyPrefab;
    [FieldOffset(32)]
    public FP BaseInterval;
    [FieldOffset(0)]
    public Int32 BaseBatchSize;
    [FieldOffset(24)]
    public FP BaseHP;
    [FieldOffset(16)]
    public FP BaseDamage;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 9319;
        hash = hash * 31 + EnemyPrefab.GetHashCode();
        hash = hash * 31 + BaseInterval.GetHashCode();
        hash = hash * 31 + BaseBatchSize.GetHashCode();
        hash = hash * 31 + BaseHP.GetHashCode();
        hash = hash * 31 + BaseDamage.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (SpawnSettings*)ptr;
        serializer.Stream.Serialize(&p->BaseBatchSize);
        AssetRef.Serialize(&p->EnemyPrefab, serializer);
        FP.Serialize(&p->BaseDamage, serializer);
        FP.Serialize(&p->BaseHP, serializer);
        FP.Serialize(&p->BaseInterval, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Timer {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public FP TotalTime;
    [FieldOffset(0)]
    public FP TimeLeft;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 20887;
        hash = hash * 31 + TotalTime.GetHashCode();
        hash = hash * 31 + TimeLeft.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Timer*)ptr;
        FP.Serialize(&p->TimeLeft, serializer);
        FP.Serialize(&p->TotalTime, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct UpgradeEntry {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(16)]
    public AssetRef<EntityPrototype> Prefab;
    [FieldOffset(0)]
    public Int32 Id;
    [FieldOffset(4)]
    public Int32 MinLevel;
    [FieldOffset(8)]
    public Int32 Weight;
    [FieldOffset(12)]
    public QBoolean CanBeRepeated;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 8101;
        hash = hash * 31 + Prefab.GetHashCode();
        hash = hash * 31 + Id.GetHashCode();
        hash = hash * 31 + MinLevel.GetHashCode();
        hash = hash * 31 + Weight.GetHashCode();
        hash = hash * 31 + CanBeRepeated.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (UpgradeEntry*)ptr;
        serializer.Stream.Serialize(&p->Id);
        serializer.Stream.Serialize(&p->MinLevel);
        serializer.Stream.Serialize(&p->Weight);
        QBoolean.Serialize(&p->CanBeRepeated, serializer);
        AssetRef.Serialize(&p->Prefab, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct _globals_ {
    public const Int32 SIZE = 1192;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public AssetRef<Map> Map;
    [FieldOffset(8)]
    public FP DeltaTime;
    [FieldOffset(16)]
    public NavMeshRegionMask NavMeshRegions;
    [FieldOffset(80)]
    public PhysicsEngineState PhysicsState2D;
    [FieldOffset(96)]
    public PhysicsEngineState PhysicsState3D;
    [FieldOffset(112)]
    public RNGSession RngSession;
    [FieldOffset(128)]
    public FrameMetaData FrameMetaData;
    [FieldOffset(176)]
    public BitSet1024 Systems;
    [FieldOffset(304)]
    public PhysicsSceneSettings PhysicsSettings;
    [FieldOffset(600)]
    public Int32 PlayerConnectedCount;
    [FieldOffset(608)]
    [FramePrinter.FixedArrayAttribute(typeof(Input), 6)]
    private fixed Byte _input_[576];
    [FieldOffset(1184)]
    public BitSet6 PlayerLastConnectionState;
    public FixedArray<Input> input {
      get {
        fixed (byte* p = _input_) { return new FixedArray<Input>(p, 96, 6); }
      }
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 12473;
        hash = hash * 31 + Map.GetHashCode();
        hash = hash * 31 + DeltaTime.GetHashCode();
        hash = hash * 31 + NavMeshRegions.GetHashCode();
        hash = hash * 31 + PhysicsState2D.GetHashCode();
        hash = hash * 31 + PhysicsState3D.GetHashCode();
        hash = hash * 31 + RngSession.GetHashCode();
        hash = hash * 31 + FrameMetaData.GetHashCode();
        hash = hash * 31 + Systems.GetHashCode();
        hash = hash * 31 + PhysicsSettings.GetHashCode();
        hash = hash * 31 + PlayerConnectedCount.GetHashCode();
        hash = hash * 31 + HashCodeUtils.GetArrayHashCode(input);
        hash = hash * 31 + PlayerLastConnectionState.GetHashCode();
        return hash;
      }
    }
    static partial void SerializeCodeGen(void* ptr, FrameSerializer serializer) {
        var p = (_globals_*)ptr;
        AssetRef.Serialize(&p->Map, serializer);
        FP.Serialize(&p->DeltaTime, serializer);
        NavMeshRegionMask.Serialize(&p->NavMeshRegions, serializer);
        PhysicsEngineState.Serialize(&p->PhysicsState2D, serializer);
        PhysicsEngineState.Serialize(&p->PhysicsState3D, serializer);
        RNGSession.Serialize(&p->RngSession, serializer);
        FrameMetaData.Serialize(&p->FrameMetaData, serializer);
        Quantum.BitSet1024.Serialize(&p->Systems, serializer);
        PhysicsSceneSettings.Serialize(&p->PhysicsSettings, serializer);
        serializer.Stream.Serialize(&p->PlayerConnectedCount);
        FixedArray.Serialize(p->input, serializer, Statics.SerializeInput);
        Quantum.BitSet6.Serialize(&p->PlayerLastConnectionState, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct AreaWeaponComponent : Quantum.IComponent {
    public const Int32 SIZE = 32;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public Int32 Damage;
    [FieldOffset(8)]
    public Int32 DamageCooldown;
    [FieldOffset(4)]
    [ExcludeFromPrototype()]
    public Int32 DamageCdTicks;
    [FieldOffset(12)]
    public QBoolean IsDamageTick;
    [FieldOffset(16)]
    [ExcludeFromPrototype()]
    public FP Elapsed;
    [FieldOffset(24)]
    public FP TimeToLive;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 7457;
        hash = hash * 31 + Damage.GetHashCode();
        hash = hash * 31 + DamageCooldown.GetHashCode();
        hash = hash * 31 + DamageCdTicks.GetHashCode();
        hash = hash * 31 + IsDamageTick.GetHashCode();
        hash = hash * 31 + Elapsed.GetHashCode();
        hash = hash * 31 + TimeToLive.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (AreaWeaponComponent*)ptr;
        serializer.Stream.Serialize(&p->Damage);
        serializer.Stream.Serialize(&p->DamageCdTicks);
        serializer.Stream.Serialize(&p->DamageCooldown);
        QBoolean.Serialize(&p->IsDamageTick, serializer);
        FP.Serialize(&p->Elapsed, serializer);
        FP.Serialize(&p->TimeToLive, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Ball : Quantum.IComponent {
    public const Int32 SIZE = 32;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public FPVector3 Velocity;
    [FieldOffset(0)]
    public EntityRef Paddle;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 4003;
        hash = hash * 31 + Velocity.GetHashCode();
        hash = hash * 31 + Paddle.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Ball*)ptr;
        EntityRef.Serialize(&p->Paddle, serializer);
        FPVector3.Serialize(&p->Velocity, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Character : Quantum.IComponent {
    public const Int32 SIZE = 96;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(24)]
    public FP MaxHealth;
    [FieldOffset(8)]
    public FP CurrentHealth;
    [FieldOffset(0)]
    public QBoolean IsDead;
    [FieldOffset(56)]
    public FP MoveSpeed;
    [FieldOffset(16)]
    public FP HorizontalTurnSpeedDegrees;
    [FieldOffset(72)]
    public FP VerticalTurnSpeedDegrees;
    [FieldOffset(64)]
    [ExcludeFromPrototype()]
    public FP VerticalLookPitch;
    [FieldOffset(32)]
    public FP MaxVerticalLook;
    [FieldOffset(48)]
    public FP MinVerticalLook;
    [FieldOffset(40)]
    public FP MinHeightLimit;
    [FieldOffset(80)]
    [ExcludeFromPrototype()]
    public FPVector2 LookDelta;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 13711;
        hash = hash * 31 + MaxHealth.GetHashCode();
        hash = hash * 31 + CurrentHealth.GetHashCode();
        hash = hash * 31 + IsDead.GetHashCode();
        hash = hash * 31 + MoveSpeed.GetHashCode();
        hash = hash * 31 + HorizontalTurnSpeedDegrees.GetHashCode();
        hash = hash * 31 + VerticalTurnSpeedDegrees.GetHashCode();
        hash = hash * 31 + VerticalLookPitch.GetHashCode();
        hash = hash * 31 + MaxVerticalLook.GetHashCode();
        hash = hash * 31 + MinVerticalLook.GetHashCode();
        hash = hash * 31 + MinHeightLimit.GetHashCode();
        hash = hash * 31 + LookDelta.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Character*)ptr;
        QBoolean.Serialize(&p->IsDead, serializer);
        FP.Serialize(&p->CurrentHealth, serializer);
        FP.Serialize(&p->HorizontalTurnSpeedDegrees, serializer);
        FP.Serialize(&p->MaxHealth, serializer);
        FP.Serialize(&p->MaxVerticalLook, serializer);
        FP.Serialize(&p->MinHeightLimit, serializer);
        FP.Serialize(&p->MinVerticalLook, serializer);
        FP.Serialize(&p->MoveSpeed, serializer);
        FP.Serialize(&p->VerticalLookPitch, serializer);
        FP.Serialize(&p->VerticalTurnSpeedDegrees, serializer);
        FPVector2.Serialize(&p->LookDelta, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct EnemyAI : Quantum.IComponent {
    public const Int32 SIZE = 56;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(24)]
    public FP Health;
    [FieldOffset(48)]
    public FP XpDrop;
    [FieldOffset(16)]
    public FP Damage;
    [FieldOffset(8)]
    public FP CloseDamageRange;
    [FieldOffset(40)]
    public FP Speed;
    [FieldOffset(32)]
    public FP MinHeightLimit;
    [FieldOffset(0)]
    public QBoolean CanMove;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 8737;
        hash = hash * 31 + Health.GetHashCode();
        hash = hash * 31 + XpDrop.GetHashCode();
        hash = hash * 31 + Damage.GetHashCode();
        hash = hash * 31 + CloseDamageRange.GetHashCode();
        hash = hash * 31 + Speed.GetHashCode();
        hash = hash * 31 + MinHeightLimit.GetHashCode();
        hash = hash * 31 + CanMove.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (EnemyAI*)ptr;
        QBoolean.Serialize(&p->CanMove, serializer);
        FP.Serialize(&p->CloseDamageRange, serializer);
        FP.Serialize(&p->Damage, serializer);
        FP.Serialize(&p->Health, serializer);
        FP.Serialize(&p->MinHeightLimit, serializer);
        FP.Serialize(&p->Speed, serializer);
        FP.Serialize(&p->XpDrop, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct EnemyRegistryComponent : Quantum.IComponentSingleton {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    public QListPtr<EnemyInfo> ActiveEnemies;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 13523;
        hash = hash * 31 + ActiveEnemies.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      ActiveEnemies = default;
    }
    public static void OnRemoved(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.EnemyRegistryComponent*)ptr;
      p->ClearPointers((Frame)frame, entity);
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (EnemyRegistryComponent*)ptr;
        QList.Serialize(&p->ActiveEnemies, serializer, Statics.SerializeEnemyInfo);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct EnemyWaveComponent : Quantum.IComponentSingleton {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    public QListPtr<EnemySpawnEntry> Entries;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 127;
        hash = hash * 31 + Entries.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      Entries = default;
    }
    public static void OnRemoved(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.EnemyWaveComponent*)ptr;
      p->ClearPointers((Frame)frame, entity);
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (EnemyWaveComponent*)ptr;
        QList.Serialize(&p->Entries, serializer, Statics.SerializeEnemySpawnEntry);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Game : Quantum.IComponentSingleton {
    public const Int32 SIZE = 40;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public GameState CurrentGameState;
    [FieldOffset(24)]
    [ExcludeFromPrototype()]
    public Timer StateTimer;
    [FieldOffset(8)]
    [ExcludeFromPrototype()]
    public Timer CountdownTimer;
    [FieldOffset(4)]
    [ExcludeFromPrototype()]
    [AllocateOnComponentAdded()]
    [FreeOnComponentRemoved()]
    public QDictionaryPtr<EntityRef, FP> Scores;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 6079;
        hash = hash * 31 + (Int32)CurrentGameState;
        hash = hash * 31 + StateTimer.GetHashCode();
        hash = hash * 31 + CountdownTimer.GetHashCode();
        hash = hash * 31 + Scores.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      if (Scores != default) f.FreeDictionary(ref Scores);
    }
    public static void OnRemoved(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.Game*)ptr;
      p->ClearPointers((Frame)frame, entity);
    }
    public void AllocatePointers(FrameBase f, EntityRef entity) {
      f.TryAllocateDictionary(ref Scores);
    }
    public static void OnAdded(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.Game*)ptr;
      p->AllocatePointers((Frame)frame, entity);
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Game*)ptr;
        serializer.Stream.Serialize((Int32*)&p->CurrentGameState);
        QDictionary.Serialize(&p->Scores, serializer, Statics.SerializeEntityRef, Statics.SerializeFP);
        Quantum.Timer.Serialize(&p->CountdownTimer, serializer);
        Quantum.Timer.Serialize(&p->StateTimer, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Goal : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    public Int32 Index;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 16223;
        hash = hash * 31 + Index.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Goal*)ptr;
        serializer.Stream.Serialize(&p->Index);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct HomingProjectileComponent : Quantum.IComponent {
    public const Int32 SIZE = 48;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public Int32 RemainingBounces;
    [FieldOffset(40)]
    public FP Speed;
    [FieldOffset(32)]
    public FP HomingStrength;
    [FieldOffset(12)]
    public QBoolean HasTarget;
    [FieldOffset(4)]
    public QBoolean CanDragTarget;
    [FieldOffset(8)]
    public QBoolean CanRepeatTarget;
    [FieldOffset(16)]
    public EntityRef CurrentTarget;
    [FieldOffset(24)]
    public EntityRef PreviousTarget;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 17041;
        hash = hash * 31 + RemainingBounces.GetHashCode();
        hash = hash * 31 + Speed.GetHashCode();
        hash = hash * 31 + HomingStrength.GetHashCode();
        hash = hash * 31 + HasTarget.GetHashCode();
        hash = hash * 31 + CanDragTarget.GetHashCode();
        hash = hash * 31 + CanRepeatTarget.GetHashCode();
        hash = hash * 31 + CurrentTarget.GetHashCode();
        hash = hash * 31 + PreviousTarget.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (HomingProjectileComponent*)ptr;
        serializer.Stream.Serialize(&p->RemainingBounces);
        QBoolean.Serialize(&p->CanDragTarget, serializer);
        QBoolean.Serialize(&p->CanRepeatTarget, serializer);
        QBoolean.Serialize(&p->HasTarget, serializer);
        EntityRef.Serialize(&p->CurrentTarget, serializer);
        EntityRef.Serialize(&p->PreviousTarget, serializer);
        FP.Serialize(&p->HomingStrength, serializer);
        FP.Serialize(&p->Speed, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct OwnerData : Quantum.IComponent {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public EntityRef OwnerEntity;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 10313;
        hash = hash * 31 + OwnerEntity.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (OwnerData*)ptr;
        EntityRef.Serialize(&p->OwnerEntity, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct PlayerLink : Quantum.IComponent {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    public PlayerRef Player;
    [FieldOffset(4)]
    [ExcludeFromPrototype()]
    public QBoolean Ready;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 21391;
        hash = hash * 31 + Player.GetHashCode();
        hash = hash * 31 + Ready.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (PlayerLink*)ptr;
        PlayerRef.Serialize(&p->Player, serializer);
        QBoolean.Serialize(&p->Ready, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct PlayerRegistryComponent : Quantum.IComponentSingleton {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    public QListPtr<PlayerInfo> ActivePlayers;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 21149;
        hash = hash * 31 + ActivePlayers.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      ActivePlayers = default;
    }
    public static void OnRemoved(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.PlayerRegistryComponent*)ptr;
      p->ClearPointers((Frame)frame, entity);
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (PlayerRegistryComponent*)ptr;
        QList.Serialize(&p->ActivePlayers, serializer, Statics.SerializePlayerInfo);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct PlayerUpgradeComponent : Quantum.IComponent {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(8)]
    public QListPtr<Int32> AcquiredUpgrades;
    [FieldOffset(4)]
    public QBoolean WaitingForChoice;
    [FieldOffset(12)]
    [AllocateOnComponentAdded()]
    public QListPtr<Int32> PendingChoices;
    [FieldOffset(0)]
    public Int32 ChosenUpgradeId;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 21481;
        hash = hash * 31 + AcquiredUpgrades.GetHashCode();
        hash = hash * 31 + WaitingForChoice.GetHashCode();
        hash = hash * 31 + PendingChoices.GetHashCode();
        hash = hash * 31 + ChosenUpgradeId.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      AcquiredUpgrades = default;
      PendingChoices = default;
    }
    public static void OnRemoved(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.PlayerUpgradeComponent*)ptr;
      p->ClearPointers((Frame)frame, entity);
    }
    public void AllocatePointers(FrameBase f, EntityRef entity) {
      f.TryAllocateList(ref PendingChoices);
    }
    public static void OnAdded(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.PlayerUpgradeComponent*)ptr;
      p->AllocatePointers((Frame)frame, entity);
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (PlayerUpgradeComponent*)ptr;
        serializer.Stream.Serialize(&p->ChosenUpgradeId);
        QBoolean.Serialize(&p->WaitingForChoice, serializer);
        QList.Serialize(&p->AcquiredUpgrades, serializer, Statics.SerializeInt32);
        QList.Serialize(&p->PendingChoices, serializer, Statics.SerializeInt32);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct ProgressionComponent : Quantum.IComponentSingleton {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public Int32 Cycle;
    [FieldOffset(16)]
    public FP TimeElapsed;
    [FieldOffset(8)]
    public FP CycleDuration;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 11003;
        hash = hash * 31 + Cycle.GetHashCode();
        hash = hash * 31 + TimeElapsed.GetHashCode();
        hash = hash * 31 + CycleDuration.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (ProgressionComponent*)ptr;
        serializer.Stream.Serialize(&p->Cycle);
        FP.Serialize(&p->CycleDuration, serializer);
        FP.Serialize(&p->TimeElapsed, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Projectile : Quantum.IComponent {
    public const Int32 SIZE = 40;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public FP Damage;
    [FieldOffset(0)]
    public Int32 HitsToDestroy;
    [FieldOffset(32)]
    public FP Velocity;
    [FieldOffset(16)]
    [ExcludeFromPrototype()]
    public FP Elapsed;
    [FieldOffset(24)]
    public FP TimeToLive;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 16141;
        hash = hash * 31 + Damage.GetHashCode();
        hash = hash * 31 + HitsToDestroy.GetHashCode();
        hash = hash * 31 + Velocity.GetHashCode();
        hash = hash * 31 + Elapsed.GetHashCode();
        hash = hash * 31 + TimeToLive.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Projectile*)ptr;
        serializer.Stream.Serialize(&p->HitsToDestroy);
        FP.Serialize(&p->Damage, serializer);
        FP.Serialize(&p->Elapsed, serializer);
        FP.Serialize(&p->TimeToLive, serializer);
        FP.Serialize(&p->Velocity, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct ShootingWeaponComponent : Quantum.IComponent {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public AssetRef<EntityPrototype> ProjectilePrefab;
    [FieldOffset(4)]
    public Int32 FireCooldown;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public Int32 FireCdTicks;
    [FieldOffset(16)]
    public FP MuzzleOffset;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 5647;
        hash = hash * 31 + ProjectilePrefab.GetHashCode();
        hash = hash * 31 + FireCooldown.GetHashCode();
        hash = hash * 31 + FireCdTicks.GetHashCode();
        hash = hash * 31 + MuzzleOffset.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (ShootingWeaponComponent*)ptr;
        serializer.Stream.Serialize(&p->FireCdTicks);
        serializer.Stream.Serialize(&p->FireCooldown);
        AssetRef.Serialize(&p->ProjectilePrefab, serializer);
        FP.Serialize(&p->MuzzleOffset, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct SlowAreaComponent : Quantum.IComponent {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public FP SlowAmount;
    [FieldOffset(8)]
    public FP SlowDuration;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 21283;
        hash = hash * 31 + SlowAmount.GetHashCode();
        hash = hash * 31 + SlowDuration.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (SlowAreaComponent*)ptr;
        FP.Serialize(&p->SlowAmount, serializer);
        FP.Serialize(&p->SlowDuration, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct SpawnerComponent : Quantum.IComponentSingleton {
    public const Int32 SIZE = 88;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(40)]
    public FP TimeSinceLastSpawn;
    [FieldOffset(8)]
    public FP CurrentInterval;
    [FieldOffset(0)]
    public Int32 CurrentBatchSize;
    [FieldOffset(24)]
    public FP HPMultiplier;
    [FieldOffset(16)]
    public FP DamageMultiplier;
    [FieldOffset(32)]
    public FP SpawnRadius;
    [FieldOffset(48)]
    public SpawnSettings Settings;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 18661;
        hash = hash * 31 + TimeSinceLastSpawn.GetHashCode();
        hash = hash * 31 + CurrentInterval.GetHashCode();
        hash = hash * 31 + CurrentBatchSize.GetHashCode();
        hash = hash * 31 + HPMultiplier.GetHashCode();
        hash = hash * 31 + DamageMultiplier.GetHashCode();
        hash = hash * 31 + SpawnRadius.GetHashCode();
        hash = hash * 31 + Settings.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (SpawnerComponent*)ptr;
        serializer.Stream.Serialize(&p->CurrentBatchSize);
        FP.Serialize(&p->CurrentInterval, serializer);
        FP.Serialize(&p->DamageMultiplier, serializer);
        FP.Serialize(&p->HPMultiplier, serializer);
        FP.Serialize(&p->SpawnRadius, serializer);
        FP.Serialize(&p->TimeSinceLastSpawn, serializer);
        Quantum.SpawnSettings.Serialize(&p->Settings, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct StatusEffectComponent : Quantum.IComponent {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public FP SlowMultiplier;
    [FieldOffset(8)]
    [ExcludeFromPrototype()]
    public FP SlowTimer;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 10597;
        hash = hash * 31 + SlowMultiplier.GetHashCode();
        hash = hash * 31 + SlowTimer.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (StatusEffectComponent*)ptr;
        FP.Serialize(&p->SlowMultiplier, serializer);
        FP.Serialize(&p->SlowTimer, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct UpgradeDataComponent : Quantum.IComponentSingleton {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(4)]
    public QListPtr<UpgradeEntry> Entries;
    [FieldOffset(0)]
    public Int32 ChoicesPerLevel;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 683;
        hash = hash * 31 + Entries.GetHashCode();
        hash = hash * 31 + ChoicesPerLevel.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      Entries = default;
    }
    public static void OnRemoved(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.UpgradeDataComponent*)ptr;
      p->ClearPointers((Frame)frame, entity);
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (UpgradeDataComponent*)ptr;
        serializer.Stream.Serialize(&p->ChoicesPerLevel);
        QList.Serialize(&p->Entries, serializer, Statics.SerializeUpgradeEntry);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Wall : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    private fixed Byte _alignment_padding_[4];
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 89;
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Wall*)ptr;
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct XPComponent : Quantum.IComponent {
    public const Int32 SIZE = 40;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public AssetRef<EntityPrototype> XpPrefab;
    [FieldOffset(32)]
    public FP TotalXP;
    [FieldOffset(16)]
    public FP CurrentXP;
    [FieldOffset(0)]
    public Int32 Level;
    [FieldOffset(24)]
    public FP Growth;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 17909;
        hash = hash * 31 + XpPrefab.GetHashCode();
        hash = hash * 31 + TotalXP.GetHashCode();
        hash = hash * 31 + CurrentXP.GetHashCode();
        hash = hash * 31 + Level.GetHashCode();
        hash = hash * 31 + Growth.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (XPComponent*)ptr;
        serializer.Stream.Serialize(&p->Level);
        AssetRef.Serialize(&p->XpPrefab, serializer);
        FP.Serialize(&p->CurrentXP, serializer);
        FP.Serialize(&p->Growth, serializer);
        FP.Serialize(&p->TotalXP, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct XPPickup : Quantum.IComponent {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public FP Value;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 15091;
        hash = hash * 31 + Value.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (XPPickup*)ptr;
        FP.Serialize(&p->Value, serializer);
    }
  }
  public unsafe partial interface ISignalOnPlayerHit : ISignal {
    void OnPlayerHit(Frame f, EntityRef target, EntityRef dealer, FP damage);
  }
  public unsafe partial interface ISignalOnPlayerDefeated : ISignal {
    void OnPlayerDefeated(Frame f, EntityRef target, EntityRef dealer);
  }
  public unsafe partial interface ISignalOnEnemyHit : ISignal {
    void OnEnemyHit(Frame f, EntityRef target, EntityRef dealer, FP damage);
  }
  public unsafe partial interface ISignalOnEnemyDefeated : ISignal {
    void OnEnemyDefeated(Frame f, EntityRef target, EntityRef dealer);
  }
  public unsafe partial interface ISignalOnGameStateChanged : ISignal {
    void OnGameStateChanged(Frame f, GameState state);
  }
  public unsafe partial interface ISignalOnGameStarted : ISignal {
    void OnGameStarted(Frame f);
  }
  public unsafe partial interface ISignalOnScoreChanged : ISignal {
    void OnScoreChanged(Frame f, EntityRef ball, EntityRef goal);
  }
  public unsafe partial interface ISignalOnGameOver : ISignal {
    void OnGameOver(Frame f);
  }
  public unsafe partial interface ISignalOnHasChoosenUpgrades : ISignal {
    void OnHasChoosenUpgrades(Frame f, EntityRef target, Int32 choosenId);
  }
  public unsafe partial interface ISignalOnXpAdquired : ISignal {
    void OnXpAdquired(Frame f, EntityRef target, FP xpAmount);
  }
  public unsafe partial interface ISignalOnLevelUp : ISignal {
    void OnLevelUp(Frame f, EntityRef target, Int32 newLevel);
  }
  public static unsafe partial class Constants {
  }
  public unsafe partial class Frame {
    private ISignalOnPlayerHit[] _ISignalOnPlayerHitSystems;
    private ISignalOnPlayerDefeated[] _ISignalOnPlayerDefeatedSystems;
    private ISignalOnEnemyHit[] _ISignalOnEnemyHitSystems;
    private ISignalOnEnemyDefeated[] _ISignalOnEnemyDefeatedSystems;
    private ISignalOnGameStateChanged[] _ISignalOnGameStateChangedSystems;
    private ISignalOnGameStarted[] _ISignalOnGameStartedSystems;
    private ISignalOnScoreChanged[] _ISignalOnScoreChangedSystems;
    private ISignalOnGameOver[] _ISignalOnGameOverSystems;
    private ISignalOnHasChoosenUpgrades[] _ISignalOnHasChoosenUpgradesSystems;
    private ISignalOnXpAdquired[] _ISignalOnXpAdquiredSystems;
    private ISignalOnLevelUp[] _ISignalOnLevelUpSystems;
    partial void AllocGen() {
      _globals = (_globals_*)Context.Allocator.AllocAndClear(sizeof(_globals_));
    }
    partial void FreeGen() {
      Context.Allocator.Free(_globals);
    }
    partial void CopyFromGen(Frame frame) {
      Native.Utils.Copy(_globals, frame._globals, sizeof(_globals_));
    }
    partial void InitGen() {
      Initialize(this, this.SimulationConfig.Entities, 256);
      _ISignalOnPlayerHitSystems = BuildSignalsArray<ISignalOnPlayerHit>();
      _ISignalOnPlayerDefeatedSystems = BuildSignalsArray<ISignalOnPlayerDefeated>();
      _ISignalOnEnemyHitSystems = BuildSignalsArray<ISignalOnEnemyHit>();
      _ISignalOnEnemyDefeatedSystems = BuildSignalsArray<ISignalOnEnemyDefeated>();
      _ISignalOnGameStateChangedSystems = BuildSignalsArray<ISignalOnGameStateChanged>();
      _ISignalOnGameStartedSystems = BuildSignalsArray<ISignalOnGameStarted>();
      _ISignalOnScoreChangedSystems = BuildSignalsArray<ISignalOnScoreChanged>();
      _ISignalOnGameOverSystems = BuildSignalsArray<ISignalOnGameOver>();
      _ISignalOnHasChoosenUpgradesSystems = BuildSignalsArray<ISignalOnHasChoosenUpgrades>();
      _ISignalOnXpAdquiredSystems = BuildSignalsArray<ISignalOnXpAdquired>();
      _ISignalOnLevelUpSystems = BuildSignalsArray<ISignalOnLevelUp>();
      _ComponentSignalsOnAdded = new ComponentReactiveCallbackInvoker[ComponentTypeId.Type.Length];
      _ComponentSignalsOnRemoved = new ComponentReactiveCallbackInvoker[ComponentTypeId.Type.Length];
      BuildSignalsArrayOnComponentAdded<Quantum.AreaWeaponComponent>();
      BuildSignalsArrayOnComponentRemoved<Quantum.AreaWeaponComponent>();
      BuildSignalsArrayOnComponentAdded<Quantum.Ball>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Ball>();
      BuildSignalsArrayOnComponentAdded<Quantum.Character>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Character>();
      BuildSignalsArrayOnComponentAdded<CharacterController2D>();
      BuildSignalsArrayOnComponentRemoved<CharacterController2D>();
      BuildSignalsArrayOnComponentAdded<CharacterController3D>();
      BuildSignalsArrayOnComponentRemoved<CharacterController3D>();
      BuildSignalsArrayOnComponentAdded<Quantum.EnemyAI>();
      BuildSignalsArrayOnComponentRemoved<Quantum.EnemyAI>();
      BuildSignalsArrayOnComponentAdded<Quantum.EnemyRegistryComponent>();
      BuildSignalsArrayOnComponentRemoved<Quantum.EnemyRegistryComponent>();
      BuildSignalsArrayOnComponentAdded<Quantum.EnemyWaveComponent>();
      BuildSignalsArrayOnComponentRemoved<Quantum.EnemyWaveComponent>();
      BuildSignalsArrayOnComponentAdded<Quantum.Game>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Game>();
      BuildSignalsArrayOnComponentAdded<Quantum.Goal>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Goal>();
      BuildSignalsArrayOnComponentAdded<Quantum.HomingProjectileComponent>();
      BuildSignalsArrayOnComponentRemoved<Quantum.HomingProjectileComponent>();
      BuildSignalsArrayOnComponentAdded<MapEntityLink>();
      BuildSignalsArrayOnComponentRemoved<MapEntityLink>();
      BuildSignalsArrayOnComponentAdded<NavMeshAvoidanceAgent>();
      BuildSignalsArrayOnComponentRemoved<NavMeshAvoidanceAgent>();
      BuildSignalsArrayOnComponentAdded<NavMeshAvoidanceObstacle>();
      BuildSignalsArrayOnComponentRemoved<NavMeshAvoidanceObstacle>();
      BuildSignalsArrayOnComponentAdded<NavMeshPathfinder>();
      BuildSignalsArrayOnComponentRemoved<NavMeshPathfinder>();
      BuildSignalsArrayOnComponentAdded<NavMeshSteeringAgent>();
      BuildSignalsArrayOnComponentRemoved<NavMeshSteeringAgent>();
      BuildSignalsArrayOnComponentAdded<Quantum.OwnerData>();
      BuildSignalsArrayOnComponentRemoved<Quantum.OwnerData>();
      BuildSignalsArrayOnComponentAdded<PhysicsBody2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsBody2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsBody3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsBody3D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCallbacks2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCallbacks2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCallbacks3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCallbacks3D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCollider2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCollider2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCollider3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCollider3D>();
      BuildSignalsArrayOnComponentAdded<PhysicsJoints2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsJoints2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsJoints3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsJoints3D>();
      BuildSignalsArrayOnComponentAdded<Quantum.PlayerLink>();
      BuildSignalsArrayOnComponentRemoved<Quantum.PlayerLink>();
      BuildSignalsArrayOnComponentAdded<Quantum.PlayerRegistryComponent>();
      BuildSignalsArrayOnComponentRemoved<Quantum.PlayerRegistryComponent>();
      BuildSignalsArrayOnComponentAdded<Quantum.PlayerUpgradeComponent>();
      BuildSignalsArrayOnComponentRemoved<Quantum.PlayerUpgradeComponent>();
      BuildSignalsArrayOnComponentAdded<Quantum.ProgressionComponent>();
      BuildSignalsArrayOnComponentRemoved<Quantum.ProgressionComponent>();
      BuildSignalsArrayOnComponentAdded<Quantum.Projectile>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Projectile>();
      BuildSignalsArrayOnComponentAdded<Quantum.ShootingWeaponComponent>();
      BuildSignalsArrayOnComponentRemoved<Quantum.ShootingWeaponComponent>();
      BuildSignalsArrayOnComponentAdded<Quantum.SlowAreaComponent>();
      BuildSignalsArrayOnComponentRemoved<Quantum.SlowAreaComponent>();
      BuildSignalsArrayOnComponentAdded<Quantum.SpawnerComponent>();
      BuildSignalsArrayOnComponentRemoved<Quantum.SpawnerComponent>();
      BuildSignalsArrayOnComponentAdded<Quantum.StatusEffectComponent>();
      BuildSignalsArrayOnComponentRemoved<Quantum.StatusEffectComponent>();
      BuildSignalsArrayOnComponentAdded<Transform2D>();
      BuildSignalsArrayOnComponentRemoved<Transform2D>();
      BuildSignalsArrayOnComponentAdded<Transform2DVertical>();
      BuildSignalsArrayOnComponentRemoved<Transform2DVertical>();
      BuildSignalsArrayOnComponentAdded<Transform3D>();
      BuildSignalsArrayOnComponentRemoved<Transform3D>();
      BuildSignalsArrayOnComponentAdded<Quantum.UpgradeDataComponent>();
      BuildSignalsArrayOnComponentRemoved<Quantum.UpgradeDataComponent>();
      BuildSignalsArrayOnComponentAdded<View>();
      BuildSignalsArrayOnComponentRemoved<View>();
      BuildSignalsArrayOnComponentAdded<Quantum.Wall>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Wall>();
      BuildSignalsArrayOnComponentAdded<Quantum.XPComponent>();
      BuildSignalsArrayOnComponentRemoved<Quantum.XPComponent>();
      BuildSignalsArrayOnComponentAdded<Quantum.XPPickup>();
      BuildSignalsArrayOnComponentRemoved<Quantum.XPPickup>();
    }
    partial void SetPlayerInputCodeGen(PlayerRef player, Input input) {
      if ((int)player >= (int)_globals->input.Length) { throw new System.ArgumentOutOfRangeException("player"); }
      var i = _globals->input.GetPointer(player);
      i->MoveAxis = input.MoveAxis;
      i->LookDelta = input.LookDelta;
      i->Forward = i->Forward.Update(this.Number, input.Forward);
      i->Reset = i->Reset.Update(this.Number, input.Reset);
      i->ChoiceFirst = i->ChoiceFirst.Update(this.Number, input.ChoiceFirst);
      i->ChoiceSecond = i->ChoiceSecond.Update(this.Number, input.ChoiceSecond);
      i->ChoiceThird = i->ChoiceThird.Update(this.Number, input.ChoiceThird);
    }
    public Input* GetPlayerInput(PlayerRef player) {
      if ((int)player >= (int)_globals->input.Length) { throw new System.ArgumentOutOfRangeException("player"); }
      return _globals->input.GetPointer(player);
    }
    partial void GetPlayerLastConnectionStateCodeGen(ref BitSetRef bitSet) {
      bitSet = new(_globals->PlayerLastConnectionState.Bits, _globals->PlayerLastConnectionState.Length);
    }
    partial void ResetPhysicsCodeGen() {
      if (Context.Physics2D != null && Physics2D.Map != null && Physics2D.Map.Guid.IsDynamic) Physics2D.ResetMap();
      Physics2D.Init(_globals->PhysicsState2D.MapStaticCollidersState.TrackedMap);
      if (Context.Physics3D != null && Physics3D.Map != null && Physics3D.Map.Guid.IsDynamic) Physics3D.ResetMap();
      Physics3D.Init(_globals->PhysicsState3D.MapStaticCollidersState.TrackedMap);
    }
    public unsafe partial struct FrameSignals {
      public void OnPlayerHit(EntityRef target, EntityRef dealer, FP damage) {
        var array = _f._ISignalOnPlayerHitSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnPlayerHit(_f, target, dealer, damage);
          }
        }
      }
      public void OnPlayerDefeated(EntityRef target, EntityRef dealer) {
        var array = _f._ISignalOnPlayerDefeatedSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnPlayerDefeated(_f, target, dealer);
          }
        }
      }
      public void OnEnemyHit(EntityRef target, EntityRef dealer, FP damage) {
        var array = _f._ISignalOnEnemyHitSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnEnemyHit(_f, target, dealer, damage);
          }
        }
      }
      public void OnEnemyDefeated(EntityRef target, EntityRef dealer) {
        var array = _f._ISignalOnEnemyDefeatedSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnEnemyDefeated(_f, target, dealer);
          }
        }
      }
      public void OnGameStateChanged(GameState state) {
        var array = _f._ISignalOnGameStateChangedSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnGameStateChanged(_f, state);
          }
        }
      }
      public void OnGameStarted() {
        var array = _f._ISignalOnGameStartedSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnGameStarted(_f);
          }
        }
      }
      public void OnScoreChanged(EntityRef ball, EntityRef goal) {
        var array = _f._ISignalOnScoreChangedSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnScoreChanged(_f, ball, goal);
          }
        }
      }
      public void OnGameOver() {
        var array = _f._ISignalOnGameOverSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnGameOver(_f);
          }
        }
      }
      public void OnHasChoosenUpgrades(EntityRef target, Int32 choosenId) {
        var array = _f._ISignalOnHasChoosenUpgradesSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnHasChoosenUpgrades(_f, target, choosenId);
          }
        }
      }
      public void OnXpAdquired(EntityRef target, FP xpAmount) {
        var array = _f._ISignalOnXpAdquiredSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnXpAdquired(_f, target, xpAmount);
          }
        }
      }
      public void OnLevelUp(EntityRef target, Int32 newLevel) {
        var array = _f._ISignalOnLevelUpSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnLevelUp(_f, target, newLevel);
          }
        }
      }
    }
  }
  public unsafe partial class Statics {
    public static FrameSerializer.Delegate SerializeEnemyInfo;
    public static FrameSerializer.Delegate SerializeEnemySpawnEntry;
    public static FrameSerializer.Delegate SerializeEntityRef;
    public static FrameSerializer.Delegate SerializeFP;
    public static FrameSerializer.Delegate SerializePlayerInfo;
    public static FrameSerializer.Delegate SerializeInt32;
    public static FrameSerializer.Delegate SerializeUpgradeEntry;
    public static FrameSerializer.Delegate SerializeInput;
    static partial void InitStaticDelegatesGen() {
      SerializeEnemyInfo = Quantum.EnemyInfo.Serialize;
      SerializeEnemySpawnEntry = Quantum.EnemySpawnEntry.Serialize;
      SerializeEntityRef = EntityRef.Serialize;
      SerializeFP = FP.Serialize;
      SerializePlayerInfo = Quantum.PlayerInfo.Serialize;
      SerializeInt32 = (v, s) => {{ s.Stream.Serialize((Int32*)v); }};
      SerializeUpgradeEntry = Quantum.UpgradeEntry.Serialize;
      SerializeInput = Quantum.Input.Serialize;
    }
    static partial void RegisterSimulationTypesGen(TypeRegistry typeRegistry) {
      typeRegistry.Register(typeof(Quantum.AreaWeaponComponent), Quantum.AreaWeaponComponent.SIZE);
      typeRegistry.Register(typeof(AssetGuid), AssetGuid.SIZE);
      typeRegistry.Register(typeof(AssetRef), AssetRef.SIZE);
      typeRegistry.Register(typeof(Quantum.Ball), Quantum.Ball.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet1024), Quantum.BitSet1024.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet128), Quantum.BitSet128.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet2048), Quantum.BitSet2048.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet256), Quantum.BitSet256.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet4096), Quantum.BitSet4096.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet512), Quantum.BitSet512.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet6), Quantum.BitSet6.SIZE);
      typeRegistry.Register(typeof(Button), Button.SIZE);
      typeRegistry.Register(typeof(CallbackFlags), 4);
      typeRegistry.Register(typeof(Quantum.Character), Quantum.Character.SIZE);
      typeRegistry.Register(typeof(CharacterController2D), CharacterController2D.SIZE);
      typeRegistry.Register(typeof(CharacterController3D), CharacterController3D.SIZE);
      typeRegistry.Register(typeof(ColorRGBA), ColorRGBA.SIZE);
      typeRegistry.Register(typeof(ComponentPrototypeRef), ComponentPrototypeRef.SIZE);
      typeRegistry.Register(typeof(ComponentTypeRef), ComponentTypeRef.SIZE);
      typeRegistry.Register(typeof(DistanceJoint), DistanceJoint.SIZE);
      typeRegistry.Register(typeof(DistanceJoint3D), DistanceJoint3D.SIZE);
      typeRegistry.Register(typeof(Quantum.EnemyAI), Quantum.EnemyAI.SIZE);
      typeRegistry.Register(typeof(Quantum.EnemyInfo), Quantum.EnemyInfo.SIZE);
      typeRegistry.Register(typeof(Quantum.EnemyRegistryComponent), Quantum.EnemyRegistryComponent.SIZE);
      typeRegistry.Register(typeof(Quantum.EnemySpawnEntry), Quantum.EnemySpawnEntry.SIZE);
      typeRegistry.Register(typeof(Quantum.EnemyWaveComponent), Quantum.EnemyWaveComponent.SIZE);
      typeRegistry.Register(typeof(EntityPrototypeRef), EntityPrototypeRef.SIZE);
      typeRegistry.Register(typeof(EntityRef), EntityRef.SIZE);
      typeRegistry.Register(typeof(FP), FP.SIZE);
      typeRegistry.Register(typeof(FPBounds2), FPBounds2.SIZE);
      typeRegistry.Register(typeof(FPBounds3), FPBounds3.SIZE);
      typeRegistry.Register(typeof(FPMatrix2x2), FPMatrix2x2.SIZE);
      typeRegistry.Register(typeof(FPMatrix3x3), FPMatrix3x3.SIZE);
      typeRegistry.Register(typeof(FPMatrix4x4), FPMatrix4x4.SIZE);
      typeRegistry.Register(typeof(FPQuaternion), FPQuaternion.SIZE);
      typeRegistry.Register(typeof(FPVector2), FPVector2.SIZE);
      typeRegistry.Register(typeof(FPVector3), FPVector3.SIZE);
      typeRegistry.Register(typeof(FrameMetaData), FrameMetaData.SIZE);
      typeRegistry.Register(typeof(FrameTimer), FrameTimer.SIZE);
      typeRegistry.Register(typeof(Quantum.Game), Quantum.Game.SIZE);
      typeRegistry.Register(typeof(Quantum.GameState), 4);
      typeRegistry.Register(typeof(Quantum.Goal), Quantum.Goal.SIZE);
      typeRegistry.Register(typeof(HingeJoint), HingeJoint.SIZE);
      typeRegistry.Register(typeof(HingeJoint3D), HingeJoint3D.SIZE);
      typeRegistry.Register(typeof(Hit), Hit.SIZE);
      typeRegistry.Register(typeof(Hit3D), Hit3D.SIZE);
      typeRegistry.Register(typeof(Quantum.HomingProjectileComponent), Quantum.HomingProjectileComponent.SIZE);
      typeRegistry.Register(typeof(Quantum.Input), Quantum.Input.SIZE);
      typeRegistry.Register(typeof(Quantum.InputButtons), 4);
      typeRegistry.Register(typeof(InputDirection), InputDirection.SIZE);
      typeRegistry.Register(typeof(InputDirectionMagnitude), InputDirectionMagnitude.SIZE);
      typeRegistry.Register(typeof(InputPitchYaw), InputPitchYaw.SIZE);
      typeRegistry.Register(typeof(IntVector2), IntVector2.SIZE);
      typeRegistry.Register(typeof(IntVector3), IntVector3.SIZE);
      typeRegistry.Register(typeof(Joint), Joint.SIZE);
      typeRegistry.Register(typeof(Joint3D), Joint3D.SIZE);
      typeRegistry.Register(typeof(LayerMask), LayerMask.SIZE);
      typeRegistry.Register(typeof(MapEntityId), MapEntityId.SIZE);
      typeRegistry.Register(typeof(MapEntityLink), MapEntityLink.SIZE);
      typeRegistry.Register(typeof(NavMeshAvoidanceAgent), NavMeshAvoidanceAgent.SIZE);
      typeRegistry.Register(typeof(NavMeshAvoidanceObstacle), NavMeshAvoidanceObstacle.SIZE);
      typeRegistry.Register(typeof(NavMeshPathfinder), NavMeshPathfinder.SIZE);
      typeRegistry.Register(typeof(NavMeshRegionMask), NavMeshRegionMask.SIZE);
      typeRegistry.Register(typeof(NavMeshSteeringAgent), NavMeshSteeringAgent.SIZE);
      typeRegistry.Register(typeof(NullableFP), NullableFP.SIZE);
      typeRegistry.Register(typeof(NullableFPVector2), NullableFPVector2.SIZE);
      typeRegistry.Register(typeof(NullableFPVector3), NullableFPVector3.SIZE);
      typeRegistry.Register(typeof(NullableNonNegativeFP), NullableNonNegativeFP.SIZE);
      typeRegistry.Register(typeof(Quantum.OwnerData), Quantum.OwnerData.SIZE);
      typeRegistry.Register(typeof(PhysicsBody2D), PhysicsBody2D.SIZE);
      typeRegistry.Register(typeof(PhysicsBody3D), PhysicsBody3D.SIZE);
      typeRegistry.Register(typeof(PhysicsCallbacks2D), PhysicsCallbacks2D.SIZE);
      typeRegistry.Register(typeof(PhysicsCallbacks3D), PhysicsCallbacks3D.SIZE);
      typeRegistry.Register(typeof(PhysicsCollider2D), PhysicsCollider2D.SIZE);
      typeRegistry.Register(typeof(PhysicsCollider3D), PhysicsCollider3D.SIZE);
      typeRegistry.Register(typeof(PhysicsEngineState), PhysicsEngineState.SIZE);
      typeRegistry.Register(typeof(PhysicsJoints2D), PhysicsJoints2D.SIZE);
      typeRegistry.Register(typeof(PhysicsJoints3D), PhysicsJoints3D.SIZE);
      typeRegistry.Register(typeof(PhysicsQueryRef), PhysicsQueryRef.SIZE);
      typeRegistry.Register(typeof(PhysicsSceneSettings), PhysicsSceneSettings.SIZE);
      typeRegistry.Register(typeof(Quantum.PlayerInfo), Quantum.PlayerInfo.SIZE);
      typeRegistry.Register(typeof(Quantum.PlayerLink), Quantum.PlayerLink.SIZE);
      typeRegistry.Register(typeof(PlayerRef), PlayerRef.SIZE);
      typeRegistry.Register(typeof(Quantum.PlayerRegistryComponent), Quantum.PlayerRegistryComponent.SIZE);
      typeRegistry.Register(typeof(Quantum.PlayerUpgradeComponent), Quantum.PlayerUpgradeComponent.SIZE);
      typeRegistry.Register(typeof(Quantum.ProgressionComponent), Quantum.ProgressionComponent.SIZE);
      typeRegistry.Register(typeof(Quantum.Projectile), Quantum.Projectile.SIZE);
      typeRegistry.Register(typeof(Ptr), Ptr.SIZE);
      typeRegistry.Register(typeof(QBoolean), QBoolean.SIZE);
      typeRegistry.Register(typeof(Quantum.Ptr), Quantum.Ptr.SIZE);
      typeRegistry.Register(typeof(QueryOptions), 2);
      typeRegistry.Register(typeof(RNGSession), RNGSession.SIZE);
      typeRegistry.Register(typeof(Shape2D), Shape2D.SIZE);
      typeRegistry.Register(typeof(Shape3D), Shape3D.SIZE);
      typeRegistry.Register(typeof(Quantum.ShootingWeaponComponent), Quantum.ShootingWeaponComponent.SIZE);
      typeRegistry.Register(typeof(Quantum.SlowAreaComponent), Quantum.SlowAreaComponent.SIZE);
      typeRegistry.Register(typeof(Quantum.SpawnSettings), Quantum.SpawnSettings.SIZE);
      typeRegistry.Register(typeof(Quantum.SpawnerComponent), Quantum.SpawnerComponent.SIZE);
      typeRegistry.Register(typeof(SpringJoint), SpringJoint.SIZE);
      typeRegistry.Register(typeof(SpringJoint3D), SpringJoint3D.SIZE);
      typeRegistry.Register(typeof(Quantum.StatusEffectComponent), Quantum.StatusEffectComponent.SIZE);
      typeRegistry.Register(typeof(Quantum.Timer), Quantum.Timer.SIZE);
      typeRegistry.Register(typeof(Transform2D), Transform2D.SIZE);
      typeRegistry.Register(typeof(Transform2DVertical), Transform2DVertical.SIZE);
      typeRegistry.Register(typeof(Transform3D), Transform3D.SIZE);
      typeRegistry.Register(typeof(Quantum.UpgradeCategory), 4);
      typeRegistry.Register(typeof(Quantum.UpgradeDataComponent), Quantum.UpgradeDataComponent.SIZE);
      typeRegistry.Register(typeof(Quantum.UpgradeEntry), Quantum.UpgradeEntry.SIZE);
      typeRegistry.Register(typeof(View), View.SIZE);
      typeRegistry.Register(typeof(Quantum.Wall), Quantum.Wall.SIZE);
      typeRegistry.Register(typeof(Quantum.XPComponent), Quantum.XPComponent.SIZE);
      typeRegistry.Register(typeof(Quantum.XPPickup), Quantum.XPPickup.SIZE);
      typeRegistry.Register(typeof(Quantum._globals_), Quantum._globals_.SIZE);
    }
    static partial void InitComponentTypeIdGen() {
      ComponentTypeId.Reset(ComponentTypeId.BuiltInComponentCount + 23)
        .AddBuiltInComponents()
        .Add<Quantum.AreaWeaponComponent>(Quantum.AreaWeaponComponent.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.Ball>(Quantum.Ball.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.Character>(Quantum.Character.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.EnemyAI>(Quantum.EnemyAI.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.EnemyRegistryComponent>(Quantum.EnemyRegistryComponent.Serialize, null, Quantum.EnemyRegistryComponent.OnRemoved, ComponentFlags.Singleton)
        .Add<Quantum.EnemyWaveComponent>(Quantum.EnemyWaveComponent.Serialize, null, Quantum.EnemyWaveComponent.OnRemoved, ComponentFlags.Singleton)
        .Add<Quantum.Game>(Quantum.Game.Serialize, Quantum.Game.OnAdded, Quantum.Game.OnRemoved, ComponentFlags.Singleton)
        .Add<Quantum.Goal>(Quantum.Goal.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.HomingProjectileComponent>(Quantum.HomingProjectileComponent.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.OwnerData>(Quantum.OwnerData.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.PlayerLink>(Quantum.PlayerLink.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.PlayerRegistryComponent>(Quantum.PlayerRegistryComponent.Serialize, null, Quantum.PlayerRegistryComponent.OnRemoved, ComponentFlags.Singleton)
        .Add<Quantum.PlayerUpgradeComponent>(Quantum.PlayerUpgradeComponent.Serialize, Quantum.PlayerUpgradeComponent.OnAdded, Quantum.PlayerUpgradeComponent.OnRemoved, ComponentFlags.None)
        .Add<Quantum.ProgressionComponent>(Quantum.ProgressionComponent.Serialize, null, null, ComponentFlags.Singleton)
        .Add<Quantum.Projectile>(Quantum.Projectile.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.ShootingWeaponComponent>(Quantum.ShootingWeaponComponent.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.SlowAreaComponent>(Quantum.SlowAreaComponent.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.SpawnerComponent>(Quantum.SpawnerComponent.Serialize, null, null, ComponentFlags.Singleton)
        .Add<Quantum.StatusEffectComponent>(Quantum.StatusEffectComponent.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.UpgradeDataComponent>(Quantum.UpgradeDataComponent.Serialize, null, Quantum.UpgradeDataComponent.OnRemoved, ComponentFlags.Singleton)
        .Add<Quantum.Wall>(Quantum.Wall.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.XPComponent>(Quantum.XPComponent.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.XPPickup>(Quantum.XPPickup.Serialize, null, null, ComponentFlags.None)
        .Finish();
    }
    [Preserve()]
    public static void EnsureNotStrippedGen() {
      FramePrinter.EnsureNotStripped();
      FramePrinter.EnsurePrimitiveNotStripped<CallbackFlags>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.GameState>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.InputButtons>();
      FramePrinter.EnsurePrimitiveNotStripped<QueryOptions>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.UpgradeCategory>();
    }
  }
}
#pragma warning restore 0109
#pragma warning restore 1591
