enum WeaponUpgradeType {
  DamageBonus,
  AddDamageMultiplier,
  AddBounce,
  AddHitsToDestroy,
  EnableHoming,
  FireRateMultiplier,
  AddAreaRangeMultiplier,
  FireRateBonus,
  BurstCountBonus,
  BurstShotDelayBonus
}

[Serializable]
struct WeaponUpgradeEffect {
  WeaponUpgradeType Type;
  FP             Value;     // e.g. +10 damage, or bounce count as int
}

[Serializable]
struct WeaponUpgradeEffects {
  [FreeOnComponentRemoved] list<WeaponUpgradeEffect> Effects;
}

enum UpgradeCategory { WeaponUnlock, WeaponUpgrade }

// Describes one upgrade or new weapon option
struct UpgradeEntry {
	AssetRef<EntityPrototype>   Prefab;         // prefab for weapon or effect entity
	int			Id;            // unique identifier for deduplication
	int         MinLevel;       // minimum player level to unlock
	int        Weight;         // relative weight in random selection
	bool		CanBeRepeated;	
  [FreeOnComponentRemoved] list<WeaponUpgradeEffects> EffectsPerExtraUpgrade;    
}

// Master list of all upgrades, editable in the Inspector
singleton component UpgradeDataComponent {
  [FreeOnComponentRemoved] list<UpgradeEntry> Entries;
  int                ChoicesPerLevel;   // e.g. 3 choices at each level up
}

component OwnerData{
	EntityRef			OwnerEntity;
}

// Per-player upgrade state
component PlayerUpgradeComponent {
  [FreeOnComponentRemoved] dictionary<int, AcquiredUpgradeInfo> AcquiredUpgrades;  // Ids of entries already taken, with count
  bool       WaitingForChoice;    // true between level-up and player pick
  [AllocateOnComponentAdded]
  [FreeOnComponentRemoved] list<int> PendingChoices; // entries currently on offer
  int		ChosenUpgradeId;
}

struct AcquiredUpgradeInfo {
    EntityRef UpgradeEntity;
    int Count;
}

event OnChooseUpgrades{ EntityRef Target; }

event OnHasChoosenUpgrades{ EntityRef Target; int ChoosenId; }
signal OnHasChoosenUpgrades ( EntityRef target, int choosenId );